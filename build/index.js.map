{
  "version": 3,
  "sources": ["../lib/node.ts", "../lib/router/findRoute.ts", "../lib/handler.ts", "../lib/router/addRoute.ts", "../lib/utils/listRoutes.ts", "../lib/utils/addRouteByMethod.ts"],
  "sourcesContent": [
    "export type Handler = string | null | Function\n\nexport type HTTPMethods = 'GET' | 'PUT' | 'DELETE' | 'OPTIONS' | 'POST'\n\nexport type HandlerMap = {\n    [K in HTTPMethods]: Handler\n}\n\nexport interface Node {\n    middleware: Handler[]\n    staticChildren: Record<string, Node>\n    handler: HandlerMap\n    dynamicChild?: Node\n    dynamicName?: string\n}\n\n// Function to create a new node\nexport const createNode = (): Node => ({\n    //@ts-ignore\n    handler: {},\n    middleware: [],\n    staticChildren: {},\n})\n\nexport const root = createNode()\n",
  "import { HTTPMethods, Handler, Node, root } from '../node'\n\ntype Params = Record<string, string>\n\ntype Return = {\n    handler: Handler\n    middleware: Handler[]\n    params: Params\n}\n\n// Function to find a route and its handler\nexport const findRoute = (path: string, method: HTTPMethods): Return | null => {\n    const { node, params } = loopSegments(path)\n    //If there's no handler, it was not defined\n    if (!node || !node.handler || !node.handler[method]) {\n        return null\n    }\n\n    return {\n        handler: node.handler[method],\n        middleware: node.middleware,\n        params,\n    }\n}\n\nfunction loopSegments(path: string) {\n    //Start at the root node\n    let node: Node | null = root\n    //Split path into segments\n    const segments = path.split('/').filter(Boolean)\n    //Initialize params object\n    const params: Params = {}\n    for (const segment of segments) {\n        //Loop through each segment\n        node = handleSegment(node, segment, params)\n        if (!node) {\n            return { node: null }\n        }\n    }\n    return { node, params }\n}\n\n//Match static -> dynamic -> 404 not found routes\nfunction handleSegment(\n    node: Node,\n    segment: string,\n    params: Params\n): Node | null {\n    // First try to match a static route\n    if (node.staticChildren[segment]) {\n        return node.staticChildren[segment]\n    }\n    // If no static route, try to match a dynamic route\n    if (node.dynamicChild) {\n        //Capture the dynamic parameter\n        params[node.dynamicChild.dynamicName!] = segment\n        return node.dynamicChild\n    } else {\n        //No matching route, exit\n        return null\n    }\n}\n",
  "import { HTTPMethods } from '.'\nimport { findRoute } from '../lib/router/findRoute'\n\nexport const handler = async (req: Request) => {\n    // URL to parse\n    const myURL = new URL(req.url)\n    const route = findRoute(myURL.pathname, req.method as HTTPMethods)\n    if (!route) {\n        return new Response(\n            `Path: '${myURL.pathname}' not found in the Igloo Router`,\n            {\n                status: 404,\n                statusText: 'Not Found',\n            }\n        )\n    }\n    if (typeof route.handler === 'function') {\n        for (const middleware of route.middleware) {\n            if (typeof middleware === 'function') {\n                await middleware(req)\n            }\n        }\n        return route.handler(req, route.params)\n    }\n    return new Response(\n        JSON.stringify({\n            pathname: myURL.pathname,\n            route,\n        })\n    )\n}\n",
  "import { Handler, Node, createNode, root } from '../node'\n// Function to add a new route\nexport function addRoute(\n    methods: string[],\n    path: string,\n    middleware: Handler[],\n    handler: Handler\n) {\n    let node: Node = root\n    const segments = path.split('/').filter(Boolean)\n\n    for (const segment of segments) {\n        //Process this segment\n        node = handleSegment(node, segment)\n    }\n    //Assign the handler to the final node\n    for (const method of methods) {\n        checkHandlerExists(node, method, path)\n        //@ts-ignore\n        node.handler[method] = handler\n    }\n    node.middleware = middleware\n}\n\n//Handles a single portion of the segment loop\nfunction handleSegment(node: Node, segment: string) {\n    //Dynamic route segment (e.g., \":userId\")\n    if (segment[0] === ':') {\n        checkDynamicChildExists(node, segment)\n        node.dynamicChild = node = createNode()\n        //Store the parameter name without the \":\"\n        node.dynamicName = segment.slice(1)\n    }\n    //Static route segment (e.g., \"users\")\n    else {\n        //Use existing or create new\n        node = node.staticChildren[segment] ??= createNode()\n    }\n    return node\n}\n\n//If there's already a dynamic child, throw and error with the segment data logged\nfunction checkDynamicChildExists(node: Node, segment: string) {\n    if (node.dynamicChild) {\n        throw new Error(\n            `Cannot have multiple of the same path. Segment:${segment}`\n        )\n    }\n}\n\n//If there's already a dynamic child, throw and error with the segment data logged\nfunction checkHandlerExists(node: Node, method: string, path: string) {\n    //@ts-ignore\n    if (node.handler[method]) {\n        throw new Error(`Cannot have multiple of the same path. Path:${path}`)\n    }\n}\n",
  "import { root, Node } from '../node'\n\ntype Route = {\n    method: string\n    path: string\n    isDynamic: boolean\n}\n\n//Loop through all of the routes and return them in an array\nexport const listRoutes = (\n    node: Node,\n    pathSoFar: string = '',\n    isDynamic: boolean = false\n): Route[] => {\n    let routes: Route[] = []\n\n    // Traverse static children\n    const staticChildrenKeys = Object.keys(node.staticChildren).sort()\n    for (const key of staticChildrenKeys) {\n        routes = routes.concat(\n            listRoutes(node.staticChildren[key], `${pathSoFar}/${key}`)\n        )\n    }\n    // Traverse dynamic child if exists\n    if (node.dynamicChild) {\n        const dynamicName = node.dynamicChild.dynamicName!\n        routes = routes.concat(\n            listRoutes(node.dynamicChild, `${pathSoFar}/:${dynamicName}`, true)\n        )\n    }\n    // Add current node's handlers\n    const methods = Object.keys(node.handler).sort() as string[]\n    routes = routes.concat(\n        methods.map((method) => ({\n            method,\n            path: pathSoFar || '/',\n            isDynamic,\n        }))\n    )\n\n    return routes\n}\n\n//Print all routes to console\nexport const printRoutes = () => {\n    const routes = listRoutes(root)\n    for (const route of routes) {\n        console.log(`${route.method} ${route.path}`)\n    }\n}\n",
  "import { HTTPMethods, Handler, addRoute } from '..'\n\nconst addRouteByMethod = (\n    method: HTTPMethods,\n    path: string,\n    middleware: Handler[],\n    handler: Handler\n) => {\n    addRoute([method], path, middleware, handler)\n}\n\nconst methodWrapper = (METHOD: HTTPMethods) => {\n    return (path: string, ...middleware: Handler[]) => {\n        const handler = middleware.pop()\n        addRouteByMethod(METHOD, path, middleware, handler!)\n    }\n}\n\nexport const router = {\n    get: methodWrapper('GET'),\n    post: methodWrapper('POST'),\n    delete: methodWrapper('DELETE'),\n    put: methodWrapper('PUT'),\n}\n"
  ],
  "mappings": "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",
  "debugId": "AA6245C309DFE46C64756e2164756e21",
  "names": []
}